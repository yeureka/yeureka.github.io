<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python 文件处理 | Yeureka</title><meta name="author" content="Yeureka"><meta name="copyright" content="Yeureka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python 文件处理 文件打开我们使用 open() 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：  “r”，以只读模式打开，你只能读取文件但不能编辑&#x2F;删除文件的任何内容 “w”，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入 “a”，以追加模式代开，写入到文件中的任何数据将自动添加到末尾  默认的模式为">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 文件处理">
<meta property="og:url" content="https://yeureka.cn/2017/07/11/Python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="Yeureka">
<meta property="og:description" content="Python 文件处理 文件打开我们使用 open() 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：  “r”，以只读模式打开，你只能读取文件但不能编辑&#x2F;删除文件的任何内容 “w”，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入 “a”，以追加模式代开，写入到文件中的任何数据将自动添加到末尾  默认的模式为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yeureka.cn/myimg/avatar.jpg">
<meta property="article:published_time" content="2017-07-11T15:10:00.000Z">
<meta property="article:modified_time" content="2024-07-26T08:32:14.982Z">
<meta property="article:author" content="Yeureka">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yeureka.cn/myimg/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python 文件处理",
  "url": "https://yeureka.cn/2017/07/11/Python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/",
  "image": "https://yeureka.cn/myimg/avatar.jpg",
  "datePublished": "2017-07-11T15:10:00.000Z",
  "dateModified": "2024-07-26T08:32:14.982Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yeureka",
      "url": "https://yeureka.cn"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yeureka.cn/2017/07/11/Python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python 文件处理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/myimg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">133</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/"><i class="fa-fw fa fa-heart"></i><span> 主站</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/index.php/%e7%95%99%e8%a8%80%e6%9d%bf/"><i class="fa-fw fas fa-comment-alt"></i><span> 留言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/myimg/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yeureka</span></a><a class="nav-page-title" href="/"><span class="site-name">Python 文件处理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/"><i class="fa-fw fa fa-heart"></i><span> 主站</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/index.php/%e7%95%99%e8%a8%80%e6%9d%bf/"><i class="fa-fw fas fa-comment-alt"></i><span> 留言</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python 文件处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-07-11T15:10:00.000Z" title="发表于 2017-07-11 23:10:00">2017-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-26T08:32:14.982Z" title="更新于 2024-07-26 16:32:14">2024-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python3-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%A5%BC%EF%BC%89/">Python3 简明教程（实验楼）</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Python 文件处理</p>
<h3 id="文件打开"><a href="#文件打开" class="headerlink" title="文件打开"></a>文件打开</h3><p>我们使用 open() 函数打开文件。它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li>“r”，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</li>
<li>“w”，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</li>
<li>“a”，以追加模式代开，写入到文件中的任何数据将自动添加到末尾</li>
</ul>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，open() 函数将会以只读模式打开文件。我们将实验打开一个文件，不过要准备实验材料：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://labfile.oss.aliyuncs.com/courses/596/sample.txt</span><br></pre></td></tr></table></figure>
<p>然后进入 Python3 打开这个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&quot;sample.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; fobj</span><br><span class="line">&lt;open file &#x27;sample.txt&#x27;, mode &#x27;r&#x27; at 0xb7f2d968&gt;</span><br></pre></td></tr></table></figure>
<h3 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h3><p>打开文件后我们应该总是关闭文件。我们使用方法 close() 完成这个操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>始终确保你显式关闭每个打开的文件，一旦它的工作完成你没有任何理由保持打开文件。因为程序能打开的文件数量是有上限的。如果你超出了这个限制，没有任何可靠的方法恢复，因此程序可能会崩溃。每个打开的文件关联的数据结构（文件描述符/句柄/文件锁…）都要消耗一些主存资源。因此如果许多打开的文件没用了你可以结束大量的内存浪费，并且文件打开时始终存在数据损坏或丢失的可能性。</p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>使用 read() 方法一次性读取整个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&quot;sample.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; fobj.read()</span><br><span class="line">&#x27;I love Python\nI love shiyanlou\n&#x27;</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>如果你再一次调用 read()，它会返回空字符串因为它已经读取完整个文件。</p>
<p>read(size) 有一个可选的参数 size，用于指定字符串长度。如果没有指定 size 或者指定为负数，就会读取并返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 size 读取和返回数据。</p>
<p>readline() 能帮助你每次读取文件的一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&quot;sample.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; fobj.readline()</span><br><span class="line">&#x27;I love Python\n&#x27;</span><br><span class="line">&gt;&gt;&gt; fobj.readline()</span><br><span class="line">&#x27;I love shiyanlou\n&#x27;</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>使用 readlines() 方法读取所有行到一个列表中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&#x27;sample.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.readlines()</span><br><span class="line">[&#x27;I love Python\n&#x27;, &#x27;I love shiyanlou\n&#x27;]</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>你可以循环遍历文件对象来读取文件中的每一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&#x27;sample.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; for x in fobj:</span><br><span class="line">...     print(x, end = &#x27;&#x27;)</span><br><span class="line">... </span><br><span class="line">I love Python</span><br><span class="line">I love shiyanlou</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>让我们写一个程序，这个程序接受用户输入的字符串作为将要读取的文件的文件名，并且在屏幕上打印文件内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">name = input(&quot;Enter the file name: &quot;)</span><br><span class="line">fobj = open(name)</span><br><span class="line">print(fobj.read())</span><br><span class="line">fobj.close()</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.py</span><br><span class="line">Enter the file name: sample.txt</span><br><span class="line">I love Python</span><br><span class="line">I love shiyanlou</span><br></pre></td></tr></table></figure>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>让我们通过 write() 方法打开一个文件然后我们随便写入一些文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&quot;ircnicks.txt&quot;, &#x27;w&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.write(&#x27;powerpork\n&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.write(&#x27;indrag\n&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.write(&#x27;mishti\n&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.write(&#x27;sankarshan&#x27;)</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br></pre></td></tr></table></figure>
<p>现在读取我们刚刚创建的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fobj = open(&#x27;ircnicks.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; s = fobj.read()</span><br><span class="line">&gt;&gt;&gt; fobj.close()</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">powerpork</span><br><span class="line">indrag</span><br><span class="line">mishti</span><br><span class="line">sankarshan</span><br></pre></td></tr></table></figure>

<h3 id="文件操作示例程序"><a href="#文件操作示例程序" class="headerlink" title="文件操作示例程序"></a>文件操作示例程序</h3><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><p>在这个例子里我们拷贝给定的文本文件到另一个给定的文本文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">sys.argv 获得所有输入程序的外部参数的列表</span><br><span class="line"></span><br><span class="line">Example：</span><br><span class="line">$ ./copyfile.py sample.txt sample2.txt</span><br><span class="line">Result:</span><br><span class="line">sys.argv == [&#x27;copyfile.py&#x27;, &#x27;sample.txt&#x27;, &#x27;sample2.txt&#x27;]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">if len(sys.argv) &lt; 3:</span><br><span class="line">    print(&quot;Wrong parameter&quot;)</span><br><span class="line">    print(&quot;./copyfile.py file1 file2&quot;)</span><br><span class="line">    sys.exit(1)</span><br><span class="line">f1 = open(sys.argv[1])</span><br><span class="line">s = f1.read()</span><br><span class="line">f1.close()</span><br><span class="line">f2 = open(sys.argv[2], &#x27;w&#x27;)</span><br><span class="line">f2.write(s)</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure>

<p>你可以看到我们在这里使用了一个新模块 sys。sys.argv 包含所有命令行参数。这个程序的功能完全可以使用 shell 的 cp 命令替代：在 cp 后首先输入被拷贝的文件的文件名，然后输入新文件名。</p>
<p>sys.argv 的第一个值是命令自身的名字，下面这个程序打印命令行参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import sys</span><br><span class="line">print(&quot;First value&quot;, sys.argv[0])</span><br><span class="line">print(&quot;All values&quot;)</span><br><span class="line">for i, x  in enumerate(sys.argv):</span><br><span class="line">    print(i, x)</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./argvtest.py Hi there</span><br><span class="line">First value ./argvtest.py</span><br><span class="line">All values</span><br><span class="line">0 ./argvtest.py</span><br><span class="line">1 Hi</span><br><span class="line">2 there</span><br></pre></td></tr></table></figure>
<p>这里我们用到了一个新函数 enumerate(iterableobject)，在序列中循环时，索引位置和对应值可以使用它同时得到。</p>
<h4 id="文本文件相关信息统计"><a href="#文本文件相关信息统计" class="headerlink" title="文本文件相关信息统计"></a>文本文件相关信息统计</h4><p>让我们试着编写一个程序，对任意给定文本文件中的制表符、行、空格进行计数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def parse_file(path):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    分析给定文本文件，返回其空格、制表符、行的相关信息</span><br><span class="line"></span><br><span class="line">    :arg path: 要分析的文本文件的路径</span><br><span class="line"></span><br><span class="line">    :return: 包含空格数、制表符数、行数的元组</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fd = open(path)</span><br><span class="line">    i = 0</span><br><span class="line">    spaces = 0</span><br><span class="line">    tabs = 0</span><br><span class="line">    # i = spaces = tabs = 0 注意和 C 语言区分  i, spaces, tabs = 0 是错误写法</span><br><span class="line">    for i,line in enumerate(fd):</span><br><span class="line">        spaces += line.count(&#x27; &#x27;)</span><br><span class="line">        tabs += line.count(&#x27;\t&#x27;)</span><br><span class="line">    # 现在关闭打开的文件</span><br><span class="line">    fd.close()</span><br><span class="line"></span><br><span class="line">    # 以元组形式返回结果</span><br><span class="line">    return spaces, tabs, i + 1</span><br><span class="line"></span><br><span class="line">def main(path):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    函数用于打印文件分析结果</span><br><span class="line"></span><br><span class="line">    :arg path: 要分析的文本文件的路径</span><br><span class="line">    :return: 若文件存在则为 True，否则 False</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if os.path.exists(path):</span><br><span class="line">        spaces, tabs, lines = parse_file(path)</span><br><span class="line">        print(&quot;Spaces &#123;&#125;. tabs &#123;&#125;. lines &#123;&#125;&quot;.format(spaces, tabs, lines))</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if len(sys.argv) &gt; 1:</span><br><span class="line">        main(sys.argv[1])</span><br><span class="line">    else:</span><br><span class="line">        sys.exit(-1)</span><br><span class="line">    sys.exit(0)</span><br></pre></td></tr></table></figure>

<p>你可以看到程序有两个函数，main() 和 parse_file() ，parse_file 函数真正的分析文件并返回结果，然后在 main() 函数里打印结果。通过分割代码到一些更小的单元（函数）里，能帮助我们组织代码库并且也更容易为函数编写测试用例。</p>
<h3 id="使用-with-语句"><a href="#使用-with-语句" class="headerlink" title="使用 with 语句"></a>使用 with 语句</h3><p>在实际情况中，我们应该尝试使用 with 语句处理文件对象，它会文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#x27;sample.txt&#x27;) as fobj:</span><br><span class="line">...     for line in fobj:</span><br><span class="line">...         print(line, end = &#x27;&#x27;)</span><br><span class="line">... </span><br><span class="line">I love Python</span><br><span class="line">I love shiyanlou</span><br></pre></td></tr></table></figure>
<h3 id="实现-lscpu-命令"><a href="#实现-lscpu-命令" class="headerlink" title="实现 lscpu 命令"></a>实现 lscpu 命令</h3><p>在 Linux 下你可以使用 lscpu 命令来查看当前电脑的 CPU 相关信息，如下图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/document-uid212737labid2044timestamp1471404738283.png/wm"></p>
<p>实际上 lscpu 命令是读取 /proc/cpuinfo 这个文件的信息并美化输出，现在你可以自己写一个 Python 程序以只读模式读取 /proc/cpuinfo 这个文件，然后打印出来，这样你就有自己的一个 Python 版本的 lscpu 命令了 :）</p>
<p>记得一行一行的读取文本文件，不要一次性读取整个文件，因为有时候你读取的文件可能比可用内存还大。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yeureka.cn">Yeureka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yeureka.cn/2017/07/11/Python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">https://yeureka.cn/2017/07/11/Python%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yeureka.cn" target="_blank">Yeureka</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post-share"><div class="social-share" data-image="/myimg/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2017/07/12/Python%20%E5%BC%82%E5%B8%B8/" title="Python 异常"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python 异常</div></div><div class="info-2"><div class="info-item-1">Python 异常 在程序执行过程中发生的任何错误都是异常。每个异常显示一些相关的错误信息，比如你在 Python3 中使用 Python2 独有的语法就会发生 SyntaxError： 不小心在行首多打了一个空格就会产生 IndentationError： NameError当有人试图访问一个未定义的变量则会发生 NameError。 1234&gt;&gt;&gt; print(kushal)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;kushal&#x27; is not defined 最后一行包含了错误的详细信息，其余行显示它是如何发生（或什么引起该异常）的详细信息 TypeErrorTypeError 也是一种经常出现的异常。当操作或函数应用于不适当类型的对象时引发，一个常见的例子是对整数和字符串做加法。 1234&gt;&gt;&gt; print(1 + &quot;kushal&...</div></div></div></a><a class="pagination-related" href="/2017/07/11/Python%20%E5%87%BD%E6%95%B0/" title="Python 函数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python 函数</div></div><div class="info-2"><div class="info-item-1">Python 函数 定义一个函数我们使用关键字 def 来定义一个函数。 123def functionname(params):    statement1    statement2 让我们编写一个函数，它将接受两个整数作为输入，然后返回总和。 12&gt;&gt;&gt; def sum(a, b):...     return a + b 第二行有个 return 关键字，我们把 a + b 的值返回给调用者。 你必须像下面这样调用这个函数。 123&gt;&gt;&gt; res = sum(234234, 34453546464)&gt;&gt;&gt; res34453780698L 还记得我们上一个实验讲过的回文检查程序么，让我们编写一个函数来检查给出的字符串是否为回文，然后返回 True 或者 False。 123456789#!/usr/bin/env python3def palindrome(s):    return s == s[::-1]if __name__ == &#x27;__main__&#x27;:    s = input(&quot;E...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/03/25/01-%E5%A4%8D%E6%9D%82%E5%BA%A61%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/" title="01-复杂度1 最大子列和问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-03-25</div><div class="info-item-2">01-复杂度1 最大子列和问题</div></div><div class="info-2"><div class="info-item-1">给定KK个整数组成的序列 {N1, N2,…, Nk}，“连续子列”被定义 {Ni, N(i+1),…, Nj}，其中 1 ≤ i ≤ j ≤ K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性； 数据2：102个随机整数； 数据3：103个随机整数； 数据4：104个随机整数； 数据5：105个随机整数；  输入格式输入第1行给出正整数KK (\le 100000≤100000)；第2行给出KK个整数，其间以空格分隔。 输出格式在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例6-2 11 -4 13 -5 -2 输出样例20 代码实现PythonO(n^2)123456789101112131415161718192021def MaxSubSequenceSum(lst,...</div></div></div></a><a class="pagination-related" href="/2017/03/25/01-%E5%A4%8D%E6%9D%82%E5%BA%A62%20Maximum%20Subsequence%20Sum/" title="01-复杂度2 Maximum Subsequence Sum"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-03-25</div><div class="info-item-2">01-复杂度2 Maximum Subsequence Sum</div></div><div class="info-2"><div class="info-item-1">Given a sequence of KK integers {N1, N2,…, Nk}. A continuous subsequence is defined to be {Ni, N(i+1),…, Nj} where 1 ≤ i ≤ j ≤ K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.   Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input SpecificationE...</div></div></div></a><a class="pagination-related" href="/2017/08/05/Django%20Markdown%E5%92%8C%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" title="Django Markdown和代码高亮"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-08-05</div><div class="info-item-2">Django Markdown和代码高亮</div></div><div class="info-2"><div class="info-item-1">Django Markdown和代码高亮 Markdown 你的博文markdown越来越流行, 越来越多的写博客的博主都喜欢上了makrdown这种标记性语言的易用性和美观性. 像简书, 作业部落, Mou都是比较出名的markdown在线或者离线形式 现在我们就来markdown自己的博客, 首先是安装markdown库, 使用下面命令 12#首先是安装markdown$ sudo pip install markdown  #记得激活虚拟环境 现在说说怎么markdown你的博文, 在article下建立新文件夹templatetags,然后我们来定义的自己的 template filter, 然后在templatetags中建立init.py, 让文件夹可以被看做一个包, 然后在文件夹中新建custom_markdown.py文件, 添加代码 1234567891011121314151617import markdownfrom django import templatefrom django.template.defaultfilters import string...</div></div></div></a><a class="pagination-related" href="/2017/08/05/Django%20Template%E5%92%8C%E5%8A%A8%E6%80%81URL/" title="Django Template和动态URL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-08-05</div><div class="info-item-2">Django Template和动态URL</div></div><div class="info-2"><div class="info-item-1">Django Template和动态URL TemplateTemplate初探到目前为止我们只是简单的将后端数据显示到页面上, 没有涉及到HTML代码, 而优雅的网站总算通过CSS+HTML, 甚至还有强大的JS的支持. 在这个教程中要打造一个Blog, 所以我们设置一个Blog界面, 原本打算使用Bootstrap作为前段的工具, 不过经过@游逸的建议, 使用了更加轻量级的Pure, 同样是响应式页面设置, 这也将是未来的主流吧.. 在my_blog下添加文件名, 文件夹名为templates 12345678910111213141516171819202122232425262728293031323334$ mkdir templates#看到当前文件构成my_blog├── article│   ├── __init__.py│   ├── __pycache__│   │   ├── __init__.cpython-34.pyc│   │   ├── admin.cpython-34.pyc│   │   ├── models.cpython-34.pyc│   ...</div></div></div></a><a class="pagination-related" href="/2017/07/17/Django%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" title="Django Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-17</div><div class="info-item-2">Django Hello World</div></div><div class="info-2"><div class="info-item-1">Django Hello World Django 的特点Django 是由 Python 开发的一个免费的开源网站框架，可以用于快速搭建高性能，优雅的网站！何为优雅，请看 Django 的以下特点： 强大的数据库功能用 Python 的类继承，几行代码就可以拥有一个丰富、动态的数据库操作接口（API），如果需要你也能执行 SQL 语句进行数据库的增、删、查、改操作。 自带的强大后台功能几行简单的代码就能让你的网站拥有一个强大的后台，轻松管理你的内容！ 优雅的链接路由用正则匹配方式匹配链接，传递到对应的函数，随意定义，如你所愿。 Model(模板)系统易于扩展的 Model 系统，设计简易。易于代码解耦。 缓存系统与 memcached 或其他的缓存系统联用，更出色的表现，更快的加载速度。 国际化支持多语言英语，允许自定义翻译的字符，轻松翻译成多国语言。 Hello World 关于 Django 的环境搭建我们将在下一节中详细介绍，下面部分为初学 Django 的初体验，让读者感受 Django 搭建 Web 服务端的快捷。  在用户根目录下，新建一个 django 目录，用于...</div></div></div></a><a class="pagination-related" href="/2017/08/04/Django%20Models%E5%92%8CAdmin%E4%BB%A5%E5%8F%8AViews%E5%92%8CURL/" title="Django Models和Admin以及Views和URL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-08-04</div><div class="info-item-2">Django Models和Admin以及Views和URL</div></div><div class="info-2"><div class="info-item-1">Django Models和Admin以及Views和URL Django Shell现在我们进入Django中的交互式shell来进行数据库的增删改查等操作 123456$ python manage.py shellPython 3.4.2 (v3.4.2:ab2c023a9432, Oct  5 2014, 20:42:22)[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.(InteractiveConsole)&gt;&gt;&gt; 这里进入Django的shell和python内置的shell是非常类似的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/myimg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yeureka</div><div class="author-info-description">心如止水行如风</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">133</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yeureka" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80"><span class="toc-number">1.</span> <span class="toc-text">文件打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B3%E9%97%AD"><span class="toc-number">2.</span> <span class="toc-text">文件关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">3.</span> <span class="toc-text">文件读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">文件操作示例程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">拷贝文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">文本文件相关信息统计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-with-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">使用 with 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-lscpu-%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">实现 lscpu 命令</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/05/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuery%E8%AF%AD%E6%B3%95%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/" title="打造学术外挂大脑（三）：Query语法打造智能文献检索系统"><img src="https://youpai.yeureka.cn/picgo/202504052302915.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑（三）：Query语法打造智能文献检索系统"/></a><div class="content"><a class="title" href="/2025/04/05/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuery%E8%AF%AD%E6%B3%95%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/" title="打造学术外挂大脑（三）：Query语法打造智能文献检索系统">打造学术外挂大脑（三）：Query语法打造智能文献检索系统</a><time datetime="2025-04-05T13:30:00.000Z" title="发表于 2025-04-05 21:30:00">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/04/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" title="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南"><img src="https://youpai.yeureka.cn/picgo/202504042228945.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南"/></a><div class="content"><a class="title" href="/2025/04/04/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" title="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南">打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南</a><time datetime="2025-04-04T13:30:00.000Z" title="发表于 2025-04-04 21:30:00">2025-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E8%81%94%E5%8A%A8%E6%9E%84%E5%BB%BA%E8%AE%BA%E6%96%87%E5%BA%93/" title="打造学术外挂大脑：Zotero+Logseq联动构建论文库"><img src="https://youpai.yeureka.cn/picgo/202504032015748.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑：Zotero+Logseq联动构建论文库"/></a><div class="content"><a class="title" href="/2025/04/03/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E8%81%94%E5%8A%A8%E6%9E%84%E5%BB%BA%E8%AE%BA%E6%96%87%E5%BA%93/" title="打造学术外挂大脑：Zotero+Logseq联动构建论文库">打造学术外挂大脑：Zotero+Logseq联动构建论文库</a><time datetime="2025-04-03T03:00:00.000Z" title="发表于 2025-04-03 11:00:00">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8D%8F%E4%BD%9C%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87rpy2%E6%97%A0%E7%BC%9D%E8%BD%AC%E6%8D%A2R%E5%8F%98%E9%87%8F%E8%87%B3Python%E5%AD%97%E5%85%B8/" title="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典"><img src="https://youpai.yeureka.cn/picgo/202504011310943.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典"/></a><div class="content"><a class="title" href="/2025/04/01/%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8D%8F%E4%BD%9C%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87rpy2%E6%97%A0%E7%BC%9D%E8%BD%AC%E6%8D%A2R%E5%8F%98%E9%87%8F%E8%87%B3Python%E5%AD%97%E5%85%B8/" title="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典">跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典</a><time datetime="2025-04-01T01:00:00.000Z" title="发表于 2025-04-01 09:00:00">2025-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/%E8%A7%A3%E5%86%B3%E6%AF%8F%E6%AC%A1%20unraid%20%E9%87%8D%E5%90%AF%E4%BB%A5%E5%90%8E%20immich%20%E8%B4%A6%E6%88%B7%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/" title="解决每次 unraid 重启以后 immich 账户丢失问题"><img src="https://youpai.yeureka.cn/picgo/202408122015206.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决每次 unraid 重启以后 immich 账户丢失问题"/></a><div class="content"><a class="title" href="/2024/08/12/%E8%A7%A3%E5%86%B3%E6%AF%8F%E6%AC%A1%20unraid%20%E9%87%8D%E5%90%AF%E4%BB%A5%E5%90%8E%20immich%20%E8%B4%A6%E6%88%B7%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/" title="解决每次 unraid 重启以后 immich 账户丢失问题">解决每次 unraid 重启以后 immich 账户丢失问题</a><time datetime="2024-08-12T11:00:00.000Z" title="发表于 2024-08-12 19:00:00">2024-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2025 By Yeureka</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>备案号：沪ICP备18020215号-3</span></a><br><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img class="cloudserver-icon" src="/myimg/又拍云_logo6.png" height="19"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/"></script></div></body></html>