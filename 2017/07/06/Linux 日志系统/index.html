<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 日志系统 | Yeureka</title><meta name="author" content="Yeureka"><meta name="copyright" content="Yeureka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux 日志系统 常见的日志日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登陆过等等。 在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 日志系统">
<meta property="og:url" content="https://yeureka.github.io/2017/07/06/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Yeureka">
<meta property="og:description" content="Linux 日志系统 常见的日志日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登陆过等等。 在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yeureka.github.io/myimg/avatar.jpg">
<meta property="article:published_time" content="2017-07-06T13:46:00.000Z">
<meta property="article:modified_time" content="2024-07-26T08:31:13.411Z">
<meta property="article:author" content="Yeureka">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yeureka.github.io/myimg/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 日志系统",
  "url": "https://yeureka.github.io/2017/07/06/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/",
  "image": "https://yeureka.github.io/myimg/avatar.jpg",
  "datePublished": "2017-07-06T13:46:00.000Z",
  "dateModified": "2024-07-26T08:31:13.411Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yeureka",
      "url": "https://yeureka.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yeureka.github.io/2017/07/06/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7d089aced760295b2badc71b04db3290";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-QB2MZCC7XG"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-QB2MZCC7XG')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-QB2MZCC7XG', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "u7ukp8d8il");
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 日志系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/myimg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/"><i class="fa-fw fa fa-heart"></i><span> 主站</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/index.php/%e7%95%99%e8%a8%80%e6%9d%bf/"><i class="fa-fw fas fa-comment-alt"></i><span> 留言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/myimg/top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yeureka</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 日志系统</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/"><i class="fa-fw fa fa-heart"></i><span> 主站</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.yeureka.cn/index.php/%e7%95%99%e8%a8%80%e6%9d%bf/"><i class="fa-fw fas fa-comment-alt"></i><span> 留言</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 日志系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-07-06T13:46:00.000Z" title="发表于 2017-07-06 21:46:00">2017-07-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-26T08:31:13.411Z" title="更新于 2024-07-26 16:31:13">2024-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E6%96%B0%E7%89%88%EF%BC%89%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%A5%BC%EF%BC%89/">Linux 基础入门（新版）（实验楼）</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Linux 日志系统</p>
<h2 id="常见的日志"><a href="#常见的日志" class="headerlink" title="常见的日志"></a>常见的日志</h2><p>日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登陆过等等。</p>
<p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 <code>/var/log</code> 中，我们来看看其中有哪些日志</p>
<p>根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。</p>
<p>接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody><tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误登陆的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade 这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log</td>
<td>dpkg 命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody></table>
<p>而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息，从而记录应用程序的崩溃信息。而在本实验环境中的我们没有这个权限，所以将 apport 从内置应用值剔除，自然而然就没有它的日志信息了。</p>
<p>只闻其名，不见其人，我们并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息，在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200</span><br><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200</span><br><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200</span><br></pre></td></tr></table></figure>
<p>我们可以从中得到信息有程序作用，日期，命令，成功与否的返回码</p>
<p>我们用这样的命令来看看 auth.log 中的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less auth.log</span><br></pre></td></tr></table></figure>

<p>我们可以从中得到的信息有日期与 ip 地址的来源以及登陆的用户与工具</p>
<p>在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了那个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<p>我们通过这样的例子就可以很明显的看出区别，在本实验环境中因为是刚启动的环境，所以两个日志中的信息都是空的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less /var/log/apt/history.log</span><br><span class="line"></span><br><span class="line">less /var/log/apt/term.log</span><br></pre></td></tr></table></figure>

<p>然后我们来安装 git 这个程序，因为本实验环境中本有预装 git 所以这里真正执行的操作是一个更新的操作，但这并不影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>成功的执行之后我们再来查看两个日志的内容变化</p>
<p>其他的日志格式也都类似与之前我们所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog</p>
<p>我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">last wtmp</span><br><span class="line">last lastlog</span><br><span class="line">lastlog --help</span><br><span class="line">lastlog -u shiyanlou</span><br></pre></td></tr></table></figure>

<h2 id="配置的日志"><a href="#配置的日志" class="headerlink" title="配置的日志"></a>配置的日志</h2><p>这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。</p>
<p>这样的实现可以通过两种方式：</p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；</li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。</li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</p>
<p>rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受从各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。</p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd</p>
<p>因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog start</span><br><span class="line"></span><br><span class="line">ps aux | grep syslog</span><br></pre></td></tr></table></figure>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务</p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，</p>
<ul>
<li><p>一个是 /etc/rsyslog.conf</p>
</li>
<li><p>一个是 /etc/rsyslog.d/50-default.conf。</p>
<p>第一个主要是配置的环境，也就是 rsyslog 的加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyslog.conf </span><br><span class="line"></span><br><span class="line">vim /etc/rsyslog.d/50-default.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-simplecloud.qbox.me/1135081469416361678-wm"><br>通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。</p>
<p>上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件，怎么只是这样简单的结构。我们可以通过下图来做更深入的了解<br><img src="http://www.rsyslog.com/doc/dataflow.png"><br>（图片来源于<a target="_blank" rel="noopener" href="http://www.rsyslog.com/doc/queues_analogy.html%EF%BC%89">http://www.rsyslog.com/doc/queues_analogy.html）</a></p>
<p>Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。</p>
<p>第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages，通过这些接口实现：</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>im3195</td>
<td>RFC3195 Input Module</td>
</tr>
<tr>
<td>imfile</td>
<td>Text File Input Module</td>
</tr>
<tr>
<td>imgssapi</td>
<td>GSSAPI Syslog Input Module</td>
</tr>
<tr>
<td>imjournal</td>
<td>Systemd Journal Input Module</td>
</tr>
<tr>
<td>imklog</td>
<td>Kernel Log Input Module</td>
</tr>
<tr>
<td>imkmsg</td>
<td>/dev/kmsg Log Input Module</td>
</tr>
<tr>
<td>impstats</td>
<td>Generate Periodic Statistics of Internal Counters</td>
</tr>
<tr>
<td>imptcp</td>
<td>Plain TCP Syslog</td>
</tr>
<tr>
<td>imrelp</td>
<td>RELP Input Module</td>
</tr>
<tr>
<td>imsolaris</td>
<td>Solaris Input Module</td>
</tr>
<tr>
<td>imtcp</td>
<td>TCP Syslog Input Module</td>
</tr>
<tr>
<td>imudp</td>
<td>UDP Syslog Input Module</td>
</tr>
<tr>
<td>imuxsock</td>
<td>Unix Socket Input</td>
</tr>
</tbody></table>
<p>而 Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看</p>
<p>而这些模块接口的使用需要通过 $ModLoad 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 imklog、imuxsock 这两个模块</p>
<p>在配置中 rsyslog 支持三种配置语法格式：</p>
<ul>
<li><p>sysklogd</p>
</li>
<li><p>legacy rsyslog</p>
</li>
<li><p>RainerScript</p>
<p>sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置</p>
</li>
</ul>
<p>老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</p>
<p>注释有两种语法:</p>
<ul>
<li>井号 #</li>
<li>C-style <code>/* .. */</code></li>
</ul>
<p>执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。</p>
<p>模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。</p>
<p>legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么</p>
<p>模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement）</p>
<p>如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看官方文档</p>
<p>了解了 rsyslog 环境的配置文件之后，我们看向 <code>/etc/rsyslog.d/50-default.conf</code> 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就我们在流程图中所看见的 <code>Parser &amp; Filter Engine</code>,它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，<code>facility</code> 与 <code>priority</code>，其配置格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facility.priority　　　　　log_location</span><br></pre></td></tr></table></figure>

<p>其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 , 分割开</p>
<p>rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>kern</td>
<td>内核消息</td>
</tr>
<tr>
<td>user</td>
<td>用户信息</td>
</tr>
<tr>
<td>mail</td>
<td>邮件系统消息</td>
</tr>
<tr>
<td>daemon</td>
<td>系统服务消息</td>
</tr>
<tr>
<td>auth</td>
<td>认证系统</td>
</tr>
<tr>
<td>authpriv</td>
<td>权限系统</td>
</tr>
<tr>
<td>syslog</td>
<td>日志系统自身消息</td>
</tr>
<tr>
<td>cron</td>
<td>计划安排</td>
</tr>
<tr>
<td>news</td>
<td>新闻信息</td>
</tr>
<tr>
<td>local0~7</td>
<td>由自定义程序使用</td>
</tr>
</tbody></table>
<p>而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有一下几种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>emergency</td>
<td>系统已经无法使用了</td>
</tr>
<tr>
<td>alert</td>
<td>必须立即处理的问题</td>
</tr>
<tr>
<td>critical</td>
<td>很严重了</td>
</tr>
<tr>
<td>error</td>
<td>错误</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息</td>
</tr>
<tr>
<td>notice</td>
<td>系统正常，但是比较重要</td>
</tr>
<tr>
<td>informational</td>
<td>正常</td>
</tr>
<tr>
<td>debug</td>
<td>debug的调试信息</td>
</tr>
<tr>
<td>panic</td>
<td>很严重但是已淘汰不常用</td>
</tr>
<tr>
<td>none</td>
<td>没有优先级，不记录任何日志消息</td>
</tr>
</tbody></table>
<p>我们来看看系统中的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth,authpriv.*       /var/log/auth.log</span><br></pre></td></tr></table></figure>
<p>这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中</p>
<p>而其中有类似于这样的配置信息意思有细微的差别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern.*      -/var/log/kern.log</span><br></pre></td></tr></table></figure>
<p>- 代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</p>
<p>到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看官网的文档,需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档</p>
<p>与日志相关的还有一个还有常用的命令 logger,logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#首先将syslog启动起来</span><br><span class="line">sudo service rsyslog start</span><br><span class="line"></span><br><span class="line">#向 syslog 写入数据</span><br><span class="line">ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</span><br><span class="line"></span><br><span class="line">#查看是否有数据写入</span><br><span class="line">tail -f /var/log/syslog</span><br></pre></td></tr></table></figure>

<p>从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板</p>
<p>我们可以通过 man 来查看 logger 的更深入用法，上诉命令中</p>
<p>参数 | 内容<br>-i | 在每行都记录进程 ID<br>-t | 添加 tag 标签<br>-p | 设置日志的 facility 与 priority</p>
<h2 id="转储的日志"><a href="#转储的日志" class="headerlink" title="转储的日志"></a>转储的日志</h2><p>在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。</p>
<p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</p>
<p>大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</p>
<p>显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/logrotate</span><br></pre></td></tr></table></figure>

<p>这其中的具体意思是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># see &quot;man logrotate&quot; for details  //可以查看帮助文档</span><br><span class="line"># rotate log files weekly</span><br><span class="line">weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )</span><br><span class="line"># keep 4 weeks worth of backlogs</span><br><span class="line">rotate 4                           //最多转储4次</span><br><span class="line"># create new (empty) log files after rotating old ones</span><br><span class="line">create                             //当转储后文件不存在时创建它</span><br><span class="line"># uncomment this if you want your log files compressed</span><br><span class="line">compress                          //通过gzip压缩方式转储（nocompress可以不压缩）</span><br><span class="line"># RPM packages drop log rotation information into this directory</span><br><span class="line">include /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下</span><br><span class="line"># no packages own wtmp -- we&#x27;ll rotate them here</span><br><span class="line">/var/log/wtmp &#123;                    //设置/var/log/wtmp日志文件的转储参数</span><br><span class="line">    monthly                        //每月转储</span><br><span class="line">    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664</span><br><span class="line">    rotate 1                       //最多转储一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yeureka.github.io">Yeureka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yeureka.github.io/2017/07/06/Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">https://yeureka.github.io/2017/07/06/Linux 日志系统/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yeureka.github.io" target="_blank">Yeureka</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/myimg/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2017/07/06/Git%20%E4%BB%8B%E7%BB%8D/" title="Git 介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git 介绍</div></div><div class="info-2"><div class="info-item-1">Git 介绍 git诞生略 版本控制系统Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而大家工作的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始工作，工作完成，再把自己的修订推送给中央服务器。这类系统，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某...</div></div></div></a><a class="pagination-related" href="/2017/07/06/Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="Linux 进程管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 进程管理</div></div><div class="info-2"><div class="info-item-1">Linux 进程管理 进程的查看不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。 top 工具的使用top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化: 1$ top top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。 我们看到 top 显示的第一排，    内容 解释    top 表示当前程序的名称   11:05:18 表示当前的系统的时间   up 8 days,17:12 表示该机器已经启动了多长时间   1 user 表示当前系统中只有一个用户   load average: 0.29,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/07/05/Linux%20%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="Linux 下软件安装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-05</div><div class="info-item-2">Linux 下软件安装</div></div><div class="info-2"><div class="info-item-1">Linux 下软件安装 小贴士 注意:如果你在安装一个软件之后，无法立即使用Tab键补全这可命令，你可以尝试先执行 source ~/.zshrc，然后你就可以使用补全操作。  aptapt 包管理工具介绍 APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。  apt-getapt-get 是用于处理 apt 包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具：    工具 说明    install 其后加上软件包名，用于安装一个软件包   update 从软件源镜像服务...</div></div></div></a><a class="pagination-related" href="/2017/07/02/Linux%20%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab/" title="Linux 任务计划crontab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-02</div><div class="info-item-2">Linux 任务计划crontab</div></div><div class="info-2"><div class="info-item-1">Linux 任务计划crontab crontab 简介这里我们看一看crontab 的格式 12345678# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name command to be executed  crontab 准备crontab 在本实验环境中需要做一些特殊的准备，首先我们会启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了（在本实验环境中需要手动启动...</div></div></div></a><a class="pagination-related" href="/2017/07/04/Linux%20%E6%8C%91%E6%88%98%EF%BC%9A%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4/" title="Linux 挑战：历史命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-04</div><div class="info-item-2">Linux 挑战：历史命令</div></div><div class="info-2"><div class="info-item-1">Linux 挑战：历史命令 介绍在linux中，对于文本的处理和分析是极为重要的，现在有一个文件叫做data1，同学们可以在这里下载， 1wget http://labfile.oss.aliyuncs.com/courses/1/data1 里面记录是一些命令的记录，现在需要你从里面找出出现频率次数前3的命令并保存在 /home/shiyanlou/result。 目标 处理文本data 将结果写入result 结果包含次数和命令，如“100 ls”  提示 cut截取(-c 8- 明白含义吗) uniq -dc去重 sort 的参数选择-k1 -n -r  答案类似于 1cat data|....|....|....   &gt;  /home/shiyanlou/result 来源2016年百度校招面试题 答案1cut data1 -c 8- | sort -k 1 | uniq -dc | sort -k 1 -n -r | head -3 &gt; /home/shiyanlou/result</div></div></div></a><a class="pagination-related" href="/2017/07/02/Linux%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93/" title="Linux 命令执行顺序控制与管道"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-02</div><div class="info-item-2">Linux 命令执行顺序控制与管道</div></div><div class="info-2"><div class="info-item-1">Linux 命令执行顺序控制与管道 命令执行顺序的控制顺序执行多条命令1$ sudo apt-get update;sudo apt-get install some-tool;some-tool 有选择的执行命令&amp;&amp;使用which来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做 1$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~ 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果 1$ echo $? ||||表示与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令 1$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &#x27;sudo apt-get inst...</div></div></div></a><a class="pagination-related" href="/2017/07/04/Linux%20%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/" title="Linux 数据流重定向"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-04</div><div class="info-item-2">Linux 数据流重定向</div></div><div class="info-2"><div class="info-item-1">Linux 数据流重定向 数据流重定向简单的重定向   文件描述符 设备文件 说明    0 /dev/stdin 标准输入   1 /dev/stdout 标准输出   2 /dev/stderr 标准错误    文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。  默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出 12$ cat # （按Ctrl+C退出）  将cat的连续输出（heredoc方式）重定向到一个文件 1234567891011$ mkdir Documents$ cat &gt; Documents/test.c &lt;&lt;EOF#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;hello world...</div></div></div></a><a class="pagination-related" href="/2017/07/02/Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" title="Linux 文件系统操作与磁盘管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-02</div><div class="info-item-2">Linux 文件系统操作与磁盘管理</div></div><div class="info-2"><div class="info-item-1">Linux 文件系统操作与磁盘管理 基本操作使用 df 命令查看磁盘的容量12$ df$ df -h 使用 du 命令查看目录的容量123456789101112# 默认同样以 blocks 的大小展示$ du # 加上`-h`参数，以更易读的方式展示$ du -h# 只查看1级目录的信息$ du -h -d 0 ~# 查看2级$ du -h -d 1 ~du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。du -a #同--all 显示目录中所有文件的大小。du -s #同--summarize 仅显示总计，只列出最后加总的值。  简单的磁盘管理dd 命令简介dd命令从标准输入读入用户输入到标准输出或者一个文件 12345678910# 输出到文件$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1# 输出到标准输出$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1# bs（block size）用于指定块大小（...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/myimg/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yeureka</div><div class="author-info-description">心如止水行如风</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yeureka" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">1.</span> <span class="toc-text">常见的日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">2.</span> <span class="toc-text">配置的日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%82%A8%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">3.</span> <span class="toc-text">转储的日志</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/18/%E8%A7%A3%E9%94%81%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%EF%BC%9A%E5%9C%A8%20Unraid%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Seafile%20%E5%B9%B6%E9%85%8D%E7%BD%AE%20Frp%20%E6%8C%87%E5%8D%97/" title="解锁外网访问：在 Unraid 上部署 Seafile 并配置 Frp 指南"><img src="https://youpai.yeureka.cn/picgo/20251118110537438.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解锁外网访问：在 Unraid 上部署 Seafile 并配置 Frp 指南"/></a><div class="content"><a class="title" href="/2025/11/18/%E8%A7%A3%E9%94%81%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%EF%BC%9A%E5%9C%A8%20Unraid%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Seafile%20%E5%B9%B6%E9%85%8D%E7%BD%AE%20Frp%20%E6%8C%87%E5%8D%97/" title="解锁外网访问：在 Unraid 上部署 Seafile 并配置 Frp 指南">解锁外网访问：在 Unraid 上部署 Seafile 并配置 Frp 指南</a><time datetime="2025-11-18T04:00:00.000Z" title="发表于 2025-11-18 12:00:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/05/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuery%E8%AF%AD%E6%B3%95%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/" title="打造学术外挂大脑（三）：Query语法打造智能文献检索系统"><img src="https://youpai.yeureka.cn/picgo/202504052302915.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑（三）：Query语法打造智能文献检索系统"/></a><div class="content"><a class="title" href="/2025/04/05/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuery%E8%AF%AD%E6%B3%95%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/" title="打造学术外挂大脑（三）：Query语法打造智能文献检索系统">打造学术外挂大脑（三）：Query语法打造智能文献检索系统</a><time datetime="2025-04-05T13:30:00.000Z" title="发表于 2025-04-05 21:30:00">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/04/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" title="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南"><img src="https://youpai.yeureka.cn/picgo/202504042228945.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南"/></a><div class="content"><a class="title" href="/2025/04/04/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" title="打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南">打造学术外挂大脑：Zotero+Logseq文献笔记模版进阶指南</a><time datetime="2025-04-04T13:30:00.000Z" title="发表于 2025-04-04 21:30:00">2025-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E8%81%94%E5%8A%A8%E6%9E%84%E5%BB%BA%E8%AE%BA%E6%96%87%E5%BA%93/" title="打造学术外挂大脑：Zotero+Logseq联动构建论文库"><img src="https://youpai.yeureka.cn/picgo/202504032015748.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打造学术外挂大脑：Zotero+Logseq联动构建论文库"/></a><div class="content"><a class="title" href="/2025/04/03/%E6%89%93%E9%80%A0%E5%AD%A6%E6%9C%AF%E5%A4%96%E6%8C%82%E5%A4%A7%E8%84%91%EF%BC%9AZotero+Logseq%E8%81%94%E5%8A%A8%E6%9E%84%E5%BB%BA%E8%AE%BA%E6%96%87%E5%BA%93/" title="打造学术外挂大脑：Zotero+Logseq联动构建论文库">打造学术外挂大脑：Zotero+Logseq联动构建论文库</a><time datetime="2025-04-03T03:00:00.000Z" title="发表于 2025-04-03 11:00:00">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8D%8F%E4%BD%9C%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87rpy2%E6%97%A0%E7%BC%9D%E8%BD%AC%E6%8D%A2R%E5%8F%98%E9%87%8F%E8%87%B3Python%E5%AD%97%E5%85%B8/" title="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典"><img src="https://youpai.yeureka.cn/picgo/202504011310943.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典"/></a><div class="content"><a class="title" href="/2025/04/01/%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8D%8F%E4%BD%9C%E6%8C%87%E5%8D%97%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87rpy2%E6%97%A0%E7%BC%9D%E8%BD%AC%E6%8D%A2R%E5%8F%98%E9%87%8F%E8%87%B3Python%E5%AD%97%E5%85%B8/" title="跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典">跨语言协作指南：如何通过rpy2无缝转换R变量至Python字典</a><time datetime="2025-04-01T01:00:00.000Z" title="发表于 2025-04-01 09:00:00">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2025 By Yeureka</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>备案号：沪ICP备18020215号-3</span></a><br><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><span>本网站由 <img class="cloudserver-icon" src="https://youpai.yeureka.cn/picgo/20251115182146855.png" height="26"> 提供CDN加速/云存储服务</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyzkd7T4eE66UGD',
      clientSecret: 'e25c2a47ef2ef0b2f8dfff8616838fac0fe35883',
      repo: 'yeureka.github.io',
      owner: 'yeureka',
      admin: ['yeureka'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '9cd8c6871ccf2922c749030350109e93'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="https://cdn.bootcdn.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>